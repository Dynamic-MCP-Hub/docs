---
title: "MCP Server"
description: "Model Context Protocol server for AI agent integration"
---

The MCP Server exposes the Sari Platform's API capabilities to AI agents (like Claude Desktop) using the Model Context Protocol. It enables dynamic API discovery and execution through natural language queries.

## Overview

The MCP Server:
- Exposes three tools: `search_api_collections`, `get_openapi_spec`, `execute_api`
- Implements rate limiting per client
- Caches collection data in Redis
- Authenticates via client credentials (API Key)

## Project Structure

```
dynamic-openapi-mcp/
├── server.py                   # Main entry point
├── requirements.txt            # Python dependencies
├── src/
│   ├── api_client.py           # HTTP client for API execution
│   ├── api_collection.py       # Collection model
│   ├── api_operation.py        # Request preparation
│   ├── authentication.py       # Auth configuration model
│   ├── vector_search.py        # Vector search client
│   ├── redis_client.py         # Redis connection manager
│   ├── custom_logger.py        # Logging with audit trail
│   ├── gcp_config.py           # GCP services configuration
│   ├── rate_limiter.py         # Rate limiting implementation
│   ├── rate_limit_auth.py      # Client authentication
│   ├── rate_limit_decorator.py # Rate limit decorator
│   └── pubsub_subscriber.py    # Pub/Sub config listener
└── Dockerfile                  # Container configuration
```

## Transport Modes

| Mode | Environment | Use Case |
|------|-------------|----------|
| `stdio` | Local | Claude Desktop local development |
| `sse` | Cloud Run | Production deployment |
| `http` | Alternative | Streamable HTTP transport |

Configuration via `MCP_TRANSPORT` environment variable.

## MCP Tools

### search_api_collections

Search for API collections using semantic similarity.

```python
@mcp.tool()
@rate_limit()
async def search_api_collections(
    query_key_word: str,  # Natural language search query
    client_id: str,       # Client identifier
    api_key: str,         # Client secret
    ctx: Context
) -> str:
```

**Example:**
```
Input: "payment processing APIs"
Output:
Found 3 matching API collections:

1. Stripe Payment API (similarity: 0.89)
2. PayPal Checkout API (similarity: 0.82)
3. Square Payments API (similarity: 0.75)
```

### get_openapi_spec

Retrieve the OpenAPI specification for a collection.

```python
@mcp.tool()
@rate_limit()
async def get_openapi_spec(
    collection_name: str,  # Name from search results
    client_id: str,
    api_key: str,
    ctx: Context
) -> str:
```

### execute_api

Execute an API request against a collection.

```python
@mcp.tool()
@rate_limit()
async def execute_api(
    collection_name: str,   # Target collection
    method: str,            # HTTP method (GET, POST, etc.)
    endpoint: str,          # API endpoint path
    headers: str = None,    # JSON string of headers
    query_params: str = None,
    path_params: str = None,
    request_data: str = None,
    client_id: str,
    api_key: str,
    ctx: Context
) -> str:
```

**Example:**
```python
execute_api(
    collection_name="Stripe Payment API",
    method="POST",
    endpoint="/v1/charges",
    headers='{"Idempotency-Key": "abc123"}',
    request_data='{"amount": 1000, "currency": "usd"}'
)
```

## Authentication Model

```python
class AuthType(Enum):
    API_KEY = "apiKey"
    BASIC_AUTH = "basic"
    BEARER_TOKEN = "bearer"
    NONE = "none"

class Authentication(BaseModel):
    type: AuthType
    name: str = None      # Header/param name
    value: str = None     # Credential value
    in_location: str = None  # "header" or "query"
```

## Rate Limiting

Implements fixed window counter algorithm:

```python
class RateLimiter:
    async def check_and_increment(
        self,
        client_id: str,
        tier: str,
        limit: int,
        window_seconds: int
    ) -> dict:
        window_start = (time.time() // window_seconds) * window_seconds
        key = f"rate_limit:{tier}:{client_id}:{int(window_start)}"

        count = await redis.incr(key)
        if count == 1:
            await redis.expire(key, window_seconds * 2)

        if count > limit:
            await redis.decr(key)
            return {
                "allowed": False,
                "retry_after": window_start + window_seconds - time.time()
            }

        return {
            "allowed": True,
            "current_count": count,
            "limit": limit,
            "remaining": limit - count
        }
```

## Caching Strategy

| Key Pattern | TTL | Purpose |
|-------------|-----|---------|
| `collection_name_map:{name}` | 24h | Name to ID mapping |
| `rate_limit:config:{client_id}` | 24h | Rate limit config |
| `rate_limit:{tier}:{id}:{window}` | 2x window | Request counter |

## Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `MCP_TRANSPORT` | `sse` | Transport mode |
| `MCP_HOST` | `0.0.0.0` | Bind host |
| `MCP_PORT` | `8080` | Bind port |
| `PROTOCOL_PATH` | `/sse` | SSE endpoint path |
| `VECTOR_SEARCH_API_URL` | - | Vector search endpoint |
| `OPENAPI_SPEC_URL` | - | Collection API base URL |
| `RATE_LIMIT_CONFIG_URL` | - | Rate limit config endpoint |
| `RATE_LIMIT_ENABLED` | `false` | Enable rate limiting |
| `REDIS_HOST` | - | Redis host |
| `REDIS_PORT` | `6379` | Redis port |

## Connecting Claude Desktop

Add to Claude Desktop config (`~/Library/Application Support/Claude/claude_desktop_config.json`):

```json
{
  "mcpServers": {
    "sari-platform": {
      "command": "npx",
      "args": [
        "-y",
        "mcp-remote",
        "https://your-mcp-server.run.app/sse"
      ]
    }
  }
}
```

Or for local development:

```json
{
  "mcpServers": {
    "sari-platform": {
      "command": "python",
      "args": ["server.py"],
      "cwd": "/path/to/dynamic-openapi-mcp"
    }
  }
}
```
