---
title: "Authentication"
description: "Dual authentication system supporting Firebase and API Keys"
---

The Sari Platform implements a dual authentication system supporting both Firebase Authentication (for web users) and API Key authentication (for AI agents and external systems).

## Authentication Methods

| Method | Use Case | Headers |
|--------|----------|---------|
| Firebase Token | Admin Console, Web Users | `Authorization: Bearer {firebase_id_token}` |
| API Key | MCP Server, AI Agents | `X-Client-ID: {client_id}` + `X-API-Key: {client_secret}` |

## Firebase Authentication

### Overview

Firebase Authentication handles user identity for the Admin Console:

```
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│  Admin Console  │─────▶│    Firebase     │─────▶│   API Backend   │
│                 │      │     Auth        │      │                 │
│  1. Sign in     │      │  2. ID Token    │      │  3. Verify      │
└─────────────────┘      └─────────────────┘      └─────────────────┘
```

### Firebase Initialization

```python
def initialize_firebase():
    # Priority 1: JSON credentials from Secret Manager
    creds_json = os.environ.get('FIREBASE_SERVICE_ACCOUNT_JSON')
    if creds_json:
        creds = json.loads(creds_json)
        firebase_admin.initialize_app(credentials.Certificate(creds))
        return

    # Priority 2: Credentials file path
    creds_file = os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')
    if creds_file and os.path.exists(creds_file):
        firebase_admin.initialize_app(credentials.Certificate(creds_file))
        return

    # Priority 3: Default credentials (GCP IAM)
    firebase_admin.initialize_app(credentials.ApplicationDefault())
```

### Token Verification

```python
def verify_firebase_token(token: str) -> dict:
    try:
        decoded = auth.verify_id_token(token)
        return {
            "uid": decoded["uid"],
            "email": decoded.get("email"),
            "name": decoded.get("name"),
            "email_verified": decoded.get("email_verified", False)
        }
    except auth.ExpiredIdTokenError:
        raise HTTPException(401, "Token expired")
    except auth.RevokedIdTokenError:
        raise HTTPException(401, "Token revoked")
    except auth.InvalidIdTokenError:
        raise HTTPException(401, "Invalid token")
```

## API Key Authentication

### Overview

API Key authentication is used by the MCP Server and AI agents:

```
┌─────────────────┐      ┌─────────────────┐
│   MCP Server    │─────▶│   API Backend   │
│   (AI Agent)    │      │                 │
│                 │      │  Verify:        │
│  X-Client-ID    │      │  - client_id    │
│  X-API-Key      │      │  - client_secret│
└─────────────────┘      └─────────────────┘
```

### Credential Generation

When an admin approves a registration:

```python
@router.post("/{user_id}/approve")
async def approve_user(user_id: str, current_user = Depends(get_current_user)):
    # Generate credentials
    client_id = f"client_{secrets.token_hex(8)}"    # e.g., client_a1b2c3d4e5f6g7h8
    client_secret = secrets.token_urlsafe(32)        # 43 characters, URL-safe

    # Hash secret for storage
    hashed_secret = bcrypt.hashpw(
        client_secret.encode('utf-8'),
        bcrypt.gensalt()
    ).decode('utf-8')

    # Update profile with hashed secret
    execute("""
        UPDATE profiles SET
            client_id = %s,
            client_secret = %s,
            registration_status = 'approved'
        WHERE id = %s
    """, (client_id, hashed_secret, user_id))

    # Return plaintext (only time it's shown)
    return {"client_id": client_id, "client_secret": client_secret}
```

<Warning>
  The `client_secret` is only returned once during approval. It cannot be retrieved later.
</Warning>

### API Key Verification

```python
async def authenticate_by_api_key(client_id: str, client_secret: str) -> dict:
    # Lookup profile by client_id
    profile = query_one(
        "SELECT * FROM profiles WHERE client_id = %s",
        (client_id,)
    )

    if not profile:
        raise HTTPException(401, "Invalid client ID")

    # Verify secret against hash
    if not bcrypt.checkpw(
        client_secret.encode('utf-8'),
        profile["client_secret"].encode('utf-8')
    ):
        raise HTTPException(401, "Invalid API key")

    # Check status
    if profile["registration_status"] != "approved":
        raise HTTPException(403, "Client not approved")

    return {
        "id": profile["id"],
        "email": profile["email"],
        "role": profile["role"],
        "client_id": profile["client_id"],
        "auth_method": "api_key"
    }
```

## Dual Authentication Dependency

The API Backend supports both auth methods via a unified dependency:

```python
async def get_current_user_or_client(
    authorization: str = Header(None),
    x_client_id: str = Header(None),
    x_api_key: str = Header(None)
) -> dict:
    # Priority 1: Firebase Bearer Token
    if authorization and authorization.startswith("Bearer "):
        return await get_current_user(authorization)

    # Priority 2: API Key
    if x_client_id and x_api_key:
        return await authenticate_by_api_key(x_client_id, x_api_key)

    # Neither provided
    raise HTTPException(401, "Authentication required")
```

## Authorization

### Role-Based Access Control

| Role | registration_status | Permissions |
|------|---------------------|-------------|
| admin | approved | Full access to all resources |
| client | approved | Access to assigned collections only |
| client | pending | No API access, waiting approval |
| client | rejected | No access |

### Admin Check Pattern

```python
def require_admin(current_user: dict):
    if current_user["role"] != "admin":
        raise HTTPException(403, "Admin access required")
    if current_user.get("registration_status") != "approved":
        raise HTTPException(403, "Account not approved")
```

### Collection Access Control

```python
def check_collection_access(client_profile_id: str, collection_id: str) -> bool:
    access = query_one("""
        SELECT 1 FROM client_api_access
        WHERE client_id = %s AND api_collection_id = %s
    """, (client_profile_id, collection_id))
    return access is not None
```

## User Registration Flow

<Steps>
  <Step title="User Signs Up">
    Firebase creates user account, Backend creates profile with `pending` status
  </Step>
  <Step title="Admin Reviews">
    Admin sees pending registration in `/requests`
  </Step>
  <Step title="Admin Approves">
    Backend generates `client_id` + `client_secret`, hashes secret with bcrypt
  </Step>
  <Step title="Email Sent">
    Credentials sent to user via Resend email service
  </Step>
  <Step title="User Access">
    User can access Admin Console (Firebase) and MCP Server (API Key)
  </Step>
</Steps>

## Security Considerations

| Aspect | Implementation |
|--------|----------------|
| Firebase tokens | Short-lived (1 hour), auto-refreshed |
| API secrets | URL-safe base64, 256 bits entropy |
| Secret storage | bcrypt hash with salt |
| Transport | HTTPS/TLS required |

### Best Practices

1. **Never log credentials** - Secrets are redacted in logs
2. **One-time display** - Client secret shown only at approval
3. **Hash comparison** - Constant-time comparison via bcrypt
4. **Token expiration** - Firebase handles token lifecycle
5. **Rate limiting** - Protects against brute force

## Error Responses

```json
// Invalid token
{"detail": "Token expired"}

// Invalid credentials
{"detail": "Invalid API key"}

// Insufficient permissions
{"detail": "Admin access required"}

// Account not approved
{"detail": "Client not approved"}
```
